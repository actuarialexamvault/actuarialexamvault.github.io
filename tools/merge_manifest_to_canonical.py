#!/usr/bin/env python3
"""
Interactive merge tool

Adds entries present in a manifest (resources/pdfs/papers_manifest.json) but missing
or different in the canonical JSON (resources/pdfs/exam_links.json). Creates a backup
of the canonical file before modifying and can optionally regenerate js/pdf-links.js.

Usage examples:
  # Dry-run (default): show what would be merged
  python tools/merge_manifest_to_canonical.py --manifest resources/pdfs/papers_manifest.json \
      --canonical resources/pdfs/exam_links.json

  # Apply changes and regenerate JS
  python tools/merge_manifest_to_canonical.py --manifest resources/pdfs/papers_manifest.json \
      --canonical resources/pdfs/exam_links.json --apply --regenerate-js

"""
from __future__ import annotations

import argparse
import json
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Tuple


def load_json(path: Path) -> Dict[str, Any]:
    with path.open('r', encoding='utf-8') as f:
        return json.load(f)


def save_json(obj: Dict[str, Any], path: Path) -> None:
    with path.open('w', encoding='utf-8') as f:
        json.dump(obj, f, indent=4, ensure_ascii=False)


def manifest_to_canonical(manifest: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convert manifest shape subject->year->session->paper->url
    into canonical shape subject->session->year->paper->url
    """
    out: Dict[str, Any] = {}
    for subj, years in manifest.items():
        for year, sessions in years.items():
            for session, papers in sessions.items():
                subj_map = out.setdefault(subj, {})
                sess_map = subj_map.setdefault(session, {})
                year_map = sess_map.setdefault(year, {})
                for paper, url in papers.items():
                    # Keep whatever URL is present (could be null)
                    year_map[paper] = url
    return out


def compute_diffs(canonical: Dict[str, Any], manifest_can: Dict[str, Any]) -> List[Tuple[str, str, str, str, Any, Any]]:
    """
    Returns list of tuples:
      (subject, session, year, paper, canonical_url_or_None, manifest_url)
    Only includes entries where manifest has a non-null url and canonical is missing or different.
    """
    diffs = []
    for subj, sessions in manifest_can.items():
        for session, years in sessions.items():
            for year, papers in years.items():
                for paper, man_url in papers.items():
                    if man_url in (None, ''):
                        continue
                    can_url = None
                    if subj in canonical:
                        if session in canonical[subj]:
                            if year in canonical[subj][session]:
                                can_url = canonical[subj][session][year].get(paper)
                    if can_url != man_url:
                        diffs.append((subj, session, year, paper, can_url, man_url))
    return diffs


def apply_changes(canonical: Dict[str, Any], diffs: List[Tuple[str, str, str, str, Any, Any]]) -> None:
    for subj, session, year, paper, can_url, man_url in diffs:
        subj_map = canonical.setdefault(subj, {})
        sess_map = subj_map.setdefault(session, {})
        year_map = sess_map.setdefault(year, {})
        year_map[paper] = man_url


def write_pdf_links_js(canonical: Dict[str, Any], js_path: Path) -> None:
    header = "// This file is autogenerated by tools/merge_manifest_to_canonical.py\n// Do not edit by hand.\nconst pdfLinksMap = "
    data = json.dumps(canonical, indent=4, ensure_ascii=False)
    content = header + data + ";\n"
    js_path.write_text(content, encoding='utf-8')


def interactive_accept(diffs: List[Tuple[str, str, str, str, Any, Any]], auto: bool) -> List[Tuple[str, str, str, str, Any, Any]]:
    accepted = []
    if auto:
        return diffs[:]
    total = len(diffs)
    i = 0
    while i < total:
        subj, session, year, paper, can_url, man_url = diffs[i]
        i += 1
        print(f"\n[{i}/{total}] {subj} {session} {year} paper {paper}")
        print(f"  canonical: {can_url}")
        print(f"  manifest : {man_url}")
        print("Actions: [a]dd/update, [s]kip, [A]dd all remaining, [q]uit")
        choice = input('Choice: ').strip().lower()
        if choice == 'a':
            accepted.append((subj, session, year, paper, can_url, man_url))
        elif choice == 's' or choice == '':
            # skip
            continue
        elif choice == 'aall' or choice == 'A'.lower() or choice == 'A' or choice == 'all' or choice == 'AALL':
            # accept this and all remaining
            accepted.append((subj, session, year, paper, can_url, man_url))
            accepted.extend(diffs[i:])
            break
        elif choice == 'q':
            break
        else:
            print('Unrecognized choice; skipping')
            continue
    return accepted


def main(argv: List[str]) -> int:
    p = argparse.ArgumentParser(description='Merge manifest into canonical exam_links.json')
    p.add_argument('--manifest', required=True, help='Path to papers_manifest.json')
    p.add_argument('--canonical', required=True, help='Path to exam_links.json')
    p.add_argument('--apply', action='store_true', help='Write changes to canonical (default: dry-run)')
    p.add_argument('--backup-dir', default=None, help='Directory to store backups (defaults to canonical parent)')
    # Note: JS regeneration removed; canonical JSON is authoritative and JS should be generated
    # by a separate step if needed.
    p.add_argument('--auto', action='store_true', help='Auto-accept all diffs (non-interactive)')
    args = p.parse_args(argv)

    manifest_path = Path(args.manifest)
    canonical_path = Path(args.canonical)
    if not manifest_path.exists():
        print('Manifest not found:', manifest_path)
        return 2
    if not canonical_path.exists():
        print('Canonical JSON not found:', canonical_path)
        return 2

    manifest = load_json(manifest_path)
    canonical = load_json(canonical_path)

    manifest_can = manifest_to_canonical(manifest)

    diffs = compute_diffs(canonical, manifest_can)
    if not diffs:
        print('No diffs found. Nothing to do.')
        return 0

    print(f'Found {len(diffs)} differing or new entries from manifest -> canonical')

    # Present diffs summary
    for subj, session, year, paper, can_url, man_url in diffs:
        print(f'- {subj} {session} {year} paper {paper}:')
        print(f'    canonical: {can_url}')
        print(f'    manifest : {man_url}')

    accepted = interactive_accept(diffs, auto=args.auto)

    if not accepted:
        print('No entries accepted. Exiting.')
        return 0

    print(f'Accepted {len(accepted)} entries to be merged.')

    if not args.apply:
        print('Dry-run mode (no files modified). Use --apply to write changes.')
        return 0

    # Backup
    backup_dir = Path(args.backup_dir) if args.backup_dir else canonical_path.parent
    backup_dir.mkdir(parents=True, exist_ok=True)
    ts = datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
    backup_path = backup_dir / f'{canonical_path.name}.bak.{ts}'
    shutil.copy2(canonical_path, backup_path)
    print(f'Backed up {canonical_path} -> {backup_path}')

    # Apply
    apply_changes(canonical, accepted)
    save_json(canonical, canonical_path)
    print(f'Wrote updated canonical JSON to {canonical_path}')

    # After applying changes, regenerate memo-links.json from the examiners manifest
    try:
        regen_script = Path(__file__).resolve().parent / 'regenerate_memo_links_from_manifest.py'
        if regen_script.exists():
            print('Running memo regeneration to update resources/pdfs/memo-links.json...')
            rc = subprocess.run([sys.executable, str(regen_script)]).returncode
            if rc == 0:
                print('Memo regeneration completed successfully.')
            else:
                print(f'Memo regeneration script exited with code {rc}')
        else:
            print('Memo regeneration script not found; skipping memo update.')
    except Exception as e:
        print('Warning: failed to run memo regeneration:', e)

    return 0


if __name__ == '__main__':
    raise SystemExit(main(sys.argv[1:]))
